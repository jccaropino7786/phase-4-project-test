function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);

var stub = function stub() {
  throw new Error('You forgot to wrap your component in <UserProvider>.');
};

var initialContext = {
  isAuthenticated: false,
  isLoading: true,
  logout: stub,
  setData: stub
};
var userContext = React.createContext(initialContext);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var UserProvider = function UserProvider(props) {
  var reLogin = props.reLogin,
      children = props.children;

  var _useState = React.useState(),
      user = _useState[0],
      setUserInfos = _useState[1];

  var _useState2 = React.useState(),
      workspace = _useState2[0],
      setWorkspace = _useState2[1];

  var _useState3 = React.useState({
    isAuthenticated: false,
    isLoading: true
  }),
      status = _useState3[0],
      setStatus = _useState3[1];

  var handleChange = React.useCallback(function (_ref) {
    var user = _ref.user,
        workspace = _ref.workspace;

    if (user) {
      setUserInfos(function (prev) {
        if (!prev) setStatus({
          isAuthenticated: true,
          isLoading: false
        });
        return user;
      });
    }
    if (workspace) setWorkspace(workspace);
  }, []);
  var logout = React.useCallback(function (cb) {
    try {
      setUserInfos(undefined);
      setWorkspace(undefined);
      setStatus({
        isAuthenticated: false,
        isLoading: false
      });

      var _temp2 = function () {
        if (cb) return Promise.resolve(cb()).then(function () {});
      }();

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  }, []);
  var loginWithToken = React.useCallback(function () {
    try {
      var _temp4 = _catch(function () {
        return Promise.resolve(reLogin()).then(function (res) {
          handleChange(res);
          setStatus({
            isAuthenticated: true,
            isLoading: false
          });
        });
      }, function () {
        setStatus({
          isAuthenticated: false,
          isLoading: false
        });
      });

      return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  }, [reLogin, handleChange]);
  React.useEffect(function () {
    loginWithToken();
  }, [loginWithToken]);
  return React__default.createElement(userContext.Provider, {
    value: _extends({}, status, {
      user: user,
      workspace: workspace,
      setData: handleChange,
      logout: logout
    })
  }, children);
};

function useUserContext() {
  return React.useContext(userContext);
}

exports.UserContext = userContext;
exports.UserProvider = UserProvider;
exports.useUserContext = useUserContext;
//# sourceMappingURL=index.js.map
